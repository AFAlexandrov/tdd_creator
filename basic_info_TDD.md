 # TDD in embedded C
 Концепция скрипта опирается на книгу *Test Driven Development for Embedded C - James W. Grenning*.
 
 ##Скрипт
 Основное назначение этого скрипта - максимально отдалить разработика от нудных задач с подключением файлов, 
 прописыванием путей, созданием новых файлов и папок. Внутри файлов создаются синтаксические конструкции, 
 а в тестовом файле уже создается небольшой тест, который просто в консоле выдает сообщение об ошибке. 
 
 ## Файлы
 Основные файлы, создающиеся в блоке: *block*.h, *block*.c, *block*_internal.h, *block*_internal.c. _internal файлы 
 содержать в себе внутренние ф-ии, которые нельзя(не стоит) давать пользователю и желательно ограничить к ним доступ. 
 Единственный файл доступный пользователю - это *block*.h, все остальные так или иначе скрыты/защищены.
 
 Также в блоке содержатся файлы: *block*_test.c, *block*_test_runner.c. Первый является основным файлом, 
 где прописываются тесты и выполняется код, а второй запускает сами тесты.
 
 Блоки объединяются в проект, в котором есть файл *all_tests*.c, в нём содержиться **main** всего тестируемого проекта. 
 После тестиования достаточно будет из проекта скопировать .h (папка **inc**) и .c (папка **src**) файлы и получится готовая библиотека. 
 
## Идея TDD
Все тестирование можно свести к небольшому своду правил, придерживаюсь которым, можно написать хороший код.

1. Написать тест, который **не** будет пройден.
    >Звучит достаточно странно, однако, в этом кроется основной смысл и идея. Нужно быть уверенным, что сам по себе тест
    работает правильно, иначе, мы не можем быть уверена на 100%, что написанный нами код будет проверен 
    **достоверным** тестом.
    Код в свою очередь должен возвращать *неверное* значение, делать/не делать действие, которое 
    мы ожидаем после его выполнения. 
2. Напистать код, проходящий тест.
    >Только сейчас, удостоверившись в валидности теста можно перейти к написанию корректного кода. 
    Важно обращать внимание на то, что тесты, написаны выше не падали, из-за работы нового кода, иначе нужно
    вернуться к прошлому этапу и пройти его заново исправляя ошибки. 
3. Рефакторинг кода.
    >Сейчас много об этом говорить не стоит, так как это тема для *отдельного разговора*,
    но не сказать однозначно нельзя. 
      
    >Код, написаный выше, может проходить тесты, но часто он именно
    *проходит* тесты, а о его рациональности и читаемости часто забывают, 
    поэтому необходимо вернуться к нему заранее. При таком подходе облегчается понимание принципа работы кода, когда
    необходимо через определенный промежуток времени к нему вернуться. Например, когда один тест, 
    а точнее код ломает тесты выше, при раннем рефакторинге гораздо быстрее можно выявить ошибку,
    а в лучшем случае - на моменте рефакторига кода, недочет будет обнаружен и испрален. 
4. Написать тест, который **не** будет пройден.
    >Таким образом цепочка и замкнулась, после провренного и отрефакториного кода, можно переходить к новым тестами 
    и новому коду, который не пройдет тест. 

Важно понимать, что в тестах нужно проверять не просто работу функций <strike>в вакууме</strike> в псевдореальных условиях,
а нужно тестировать приближенную к реальности работу кода, потому что в тестах 
происходит **настоящая работа блока**, правда, максимально контролируема, но весь функционал может быть выстроен так, что
написав тесты вы проверите не тольку работу некоторых функций по отдельности, но и всего блока в целом. 

##UNIT тесты
Одним из важнейших файлов всего тестирования является - **unity.h**, находящийся по пути: 
*~/name_project/tdd_creator/Unity/unity.h*. В нём можно обнаружить инструменты для запуска тестов, о которых шла речь. 
Главная идея - это **сравнение** значение, которое ожидаем (**expected**) с пришедшим из функции или измененным
 функцией (**actual**). Такие сравнения можно провести для чего угодно: строки, указатели, массивы, 
 числа разного размера. Можно сравнивать равно ли что-то нулю или нет, равны ли субъекты вообще или нет. 
 В файле unity.h описаны эти сравнивающие макросы и по названиям, довольно просто можно понять, как пользоваться этими 
 средствами.
 
     #define TEST_ASSERT_EQUAL_PTR(expected, actual)
     
 >Выше представлена одна строчка из файла unity.h, по названию становиться понятно, что сравниваться будут **указатели**.
 Первым нужно поставить указатель, который хотели бы видеть, на втором месте должен стоять тот, что нужно проверить.
 
    #define TEST_ASSERT_EQUAL_UINT32_MESSAGE(expected, actual, message)
 
 >Чуть более интересный пример. Опять обращаем внимание на название: сравниваются два **беззнаковых** целых числа. 
 На первом ожидаемое, на втором проверяемое, а на третьем месте должно стоять сообщение (**message**), которое будет выведено, 
 если тест не пройдет. 


## Исползование скрипта и TDD

   * Создать **новый** проект

    $ ./add_block.bash project_name_new block_name 
 
  >Где *add_block* - имя скрипта, *project_name_new* - имя нового проекта с тестируемыми блоками, *block_name* - 
   имя блока, который надо тестировать. 

   * Перейти в папку с проектом и набрать в консоли 
   
    $ make
    
   >После чего должны подгрузиться другие сабмодули и собраться весь проект с тестами. Что-то такое должно повявиться
   в консоли.
   
    .test/block_name/block_name_test.c:17:TEST(block_name, start_here):FAIL: start test block_name here


    -----------------------
    1 Tests 1 Failures 0 Ignored 
    FAIL
